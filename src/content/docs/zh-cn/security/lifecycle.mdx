---
title: 应用程序生命周期威胁
sidebar:
  order: 8
---

Tauri 应用程序在应用生命周期的不同时间点由许多部分组成. 在这里, 我们将介绍典型的威胁, 以及你应该采取的应对措施.

以下章节将介绍所有不同的步骤.

![开发过程中的威胁阶段](@assets/concept/application-flow-simple.svg)

:::note

应用程序生命周期中最薄弱的环节基本上决定了应用的安全性, 每个步骤都可能影响到后续步骤的假设和完整性, 因此在任何时候都必须纵观全局.

:::

## 上游威胁

Tauri是你项目的直接依赖项, 我们严格控制提交, 审查, Pull Request和发布.
我们尽最大努力维护最新的依赖关系, 并采取措施进行更新或分支修复. 其他项目的维护工作可能没有这么完善, 甚至可能从未经过审核.

请在引入它们的时候考虑它们的安全性, 否则, 你可能在不知情的情况下引入了架构问题.

### 保持更新

当将你的应用程序发布到外部环境时, 你也在发布包含Tauri的捆绑包.
影响Tauri的漏洞可能会影响你的应用的安全性.
通过将Tauri更新到最新版本, 可以确保关键漏洞应景修复, 无法在你的应用中被利用.
同时, 请保证编译器(`rustc`) 和 转译器(`nodejs`)处于最新zhuangt.
因为经常会有很多安全问题得到解决.
这同样适用于你的开发系统.

### 评估你的依赖项

尽管 npm 和 crates.io 提供了很多方便的包,
但是你有责任选择可信赖的第三方库, 或者用 rust 重写.
如果你使用了存在漏洞影响或者不再维护的过期的库, 可能会影响到应用程序的安全性, 也可能会影响到你的睡眠质量.

使用像 [`npm audit`](https://docs.npmjs.com/cli/v10/commands/npm-audit)
和 [`cargo audit`](https://crates.io/crates/cargo-audit) 这样的工具来实现自动化这个过程, 并依赖安全社区的重要工作.

在rust生态系统中, 最新趋势是使用像 [`cargo-vet`](https://github.com/mozilla/cargo-vet)
或者 [`cargo crev`](https://github.com/crev-dev/cargo-crev) 这样的工具, 可以进一步降低供应链收到攻击的可能性.
如果想要找到提供者, 你可以使用 [`cargo supply chain`](https://github.com/rust-secure-code/cargo-supply-chain) 这个工具

我们强烈建议的一种做法是, 只从git中使用关系依赖项,最好使用hash修订,其次使用命名标签, 这不仅适用于 rust, 也适用于node生态系统.

## 开发威胁

我们假设你作为开发人员, 关心你的开发环境.
你有责任确保你的操作系统, 构建工具链, 和相关依赖项保持最新且安全合理.

我们都面临的真正风险是所谓的"供应链攻击(supply-chain attacks)", 通常是认为对项目直接依赖项的工具.
然而, 现在有越来越多的攻击直接针对开发机器, 你最好直接应对这种攻击

### 加固开发机器

加固你的开发系统取决于各种因素和你的个人威胁模型, 但我们建议你遵循一些通用的建议:

- 永远不要在日常任务(如编码)中使用管理员账户
- 永远不要在开发机器上使用生产密钥
- 防止将密钥提交到源代码版本控制中
- 使用安全硬件令牌或类似设备, 以减少系统受损的影响
- 保持系统更新
- 尽量减少安装应用程序的数量

更为实用的程序集合可以在 [awesome security hardening collection](https://github.com/decalage2/awesome-security-hardening) 中找到

当然, 你可以将开发环境虚拟化以防止攻击者入侵, 但是这并不能保护你免受针对项目而不是针对机器的攻击.

### 确保源代码控制的身份验证和授权

如果你像大多数开发者一样, 那么使用源代码版本控制工具和服务提供商在开发过程中必不可少的一部.

为了确保你的源代码不会被未授权的人修改, 了解并正确设置源代码版本控制系统的访问控制非常重要.

此外, 考虑要求所有(常规)贡献者在其提交上签名, 以防止恶意提交被归因于未受威胁或非恶意的贡献者的清空.

## 构建时威胁

现代组织使用 CI/CD 来生产二进制文件.

你需要完全信任这些远程(和属于第三方的)系统, 因为它们能完成访问源代码和secrets, 并且能够修改构建过程,
而你无法验证生成的二进制文件和你本地代码是否相同.
这意味着要么信任一个声誉良好的提供者, 要么将这些系统托管到你自己控制的硬件上.

在 Tauri, 我们提供了一个适用于多平台构建的 github workflow,
如果你创建自己的CI/CD, 并且依赖于第三方工具, 请注意那些你没有明确固定版本的操作.

你应该为你的二进制文件在你发布的平台上进行签名,
虽然这可能比较复杂, 设置起来成本较高, 但是最终用户希望能够验证你的应用确实来自于你.

如果加密密钥正确存储在硬件令牌上, 即使构建系统收到威胁, 也无法泄露涉及的秘钥签名, 但却可以利用它们来签署恶意发布的版本

### 可重现构建

为了在构建时防止后门注入, 你需要再构建过程中具有可重现性, 这样你可以验证在本地构建或在其他独立提供商上构建时, 构建资产是否完全相同

第一个问题是, rust 默认情况下并不能完全可靠的生成可重现的构建, 它在理论上支持可重现性, 但仍然存在一些bug, 而且在最近某个版本中甚至出现了破坏可重现性的情况

你可以在rust项目的 [public bug tracker](https://github.com/rust-lang/rust/labels/A-reproducibility) 中了解当前状态

下一个问题是, 许多常见的前端打包工具也无法生成可重现的输出, 因此打包后的资源也可能破坏可重现构建

这意味着你不能默认完全依赖可重现的构建, 而是需要完全信任你的构建系统

## 分发威胁

我们已经尽最大努力使应用程序发布热更新尽可能简单和安全, 然而, 如果你失去了对 manifest 服务器, 构建服务器或二进制文件托管服务的控制, 一切都将无法挽回

如果你要搭建自己的系统, 请咨询专业的运维架构师, 并确保系统搭建得当.

如果你正在为Tauri应用寻找另一种值得信赖的分发解决方案, 我们的合作伙伴 CrabNebula 提供了一个选择: [https://crabnebula.dev/cloud](https://crabnebula.dev/cloud)

## 运行时威胁

我们假设 webview 是不安全的, 这促使Tauri在加载不受信任的用户界面内容时实施了机箱保护措施, 限制了webview对系统API的访问

使用 [内容安全策略](/zh-cn/security/csp/)可以锁定webview可以进行的通信类型,
此外, [Capabilities](/zh-cn/security/capabilities/) 可以阻止不信任内容或脚本访问webview内部的API.

我们还建议建立一个简单且安全的漏洞报告机制, 类似于 [我们的处理流程](/zh-cn/security#coordinated-disclosure)
